<?xml version="1.0" encoding="UTF-8"?>


<!-- Define an Extension Type used    -->
<!ELEMENT extensiontypes (type+)>
<!ATTLIST type id ID #REQUIRED >
<!ATTLIST type name CDATA #REQUIRED >
<!ATTLIST type module CDATA #REQUIRED >
<!ELEMENT description (#PCDATA) >
<!ELEMENT type (description, context, transaction?, scope?, class?, license?, introduced?,deprecated?) >
<!ELEMENT license (feature+)>
<!ELEMENT feature (#PCDATA)>

<!--
CLASS
-->

<!ELEMENT class EMPTY>
<!ATTLIST class interface CDATA #REQUIRED >
<!ATTLIST class baseclass CDATA #IMPLIED >
 <!--
 INTRODUCED
 defines the version when this privilege came into being -->
 <!ELEMENT introduced EMPTY >
 <!ATTLIST introduced version CDATA #REQUIRED>

 <!--
 DEPRECATED
 defines the version when this privilege was deprecated.  Element data should explain the reason -->
 <!ELEMENT deprecated (#PCDATA) >
 <!ATTLIST deprecated version CDATA #REQUIRED>

<!ELEMENT context EMPTY >
<!--
FRAMEWORK_ENTITY = ues framework trigger screens to map
EXTERNAL = mapped elsewhere such as notices/gate
VARIFORM_DEF = variform definition
NONE = no triggers are used. in case of library classes
CALL_BY_NAME = code called by specific groovy name
-->
<!ATTLIST context triggermapping ( FRAMEWORK_ENTITY | EXTERNAL| VARIFORM_DEF | CALL_BY_NAME | NONE) #REQUIRED >

<!-- transaction context provided at the time of execution. Currently informational for the end user.-->
<!ELEMENT transaction EMPTY >


<!-- NONE= no transaction provided -->
<!-- NEW = new transaction opened for the calling of the extension -->
<!-- PREEXISTING= uses whatever transaction was being used for the process. Any errors will cause the main transaction to rollback. -->
<!-- SECONDARY= entity lifecycle call backs which are in a second inner session. strict limitations on what can be done apply.-->
<!ATTLIST transaction mode ( NONE  | NEW | PREEXISTING| SECONDARY | UNKNOWN) #REQUIRED >

<!ELEMENT scope EMPTY >

<!-- instantiation mode-->
<!ATTLIST scope mode ( SINGLETON | PROTOTYPE) #REQUIRED >





